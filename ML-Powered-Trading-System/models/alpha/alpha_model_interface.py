"""
Alpha Model Interface Module

This module defines the interface for alpha models, which are responsible for generating
trading signals with associated strengths (alpha values) across different instruments.
Alpha models are more sophisticated than individual strategies and may combine
multiple signal sources.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Set, Protocol
import pandas as pd
import numpy as np
import time
import uuid
import logging

from core.event_bus import EventBus

# Configure logger
logger = logging.getLogger(__name__)

class AlphaSignal:
    """
    Represents a trading signal generated by an alpha model.

    This class encapsulates all information about a trading signal,
    including direction, strength, confidence, and metadata.
    """

    def __init__(self,
                instrument: str,
                direction: str,
                strength: float,
                confidence: float,
                model_id: str,
                timestamp: float = None,
                signal_id: str = None,
                metadata: Dict[str, Any] = None,
                expiration: float = None):
        """
        Initialize a new alpha signal.

        Args:
            instrument: Trading instrument (symbol)
            direction: Signal direction ('long', 'short', or 'neutral')
            strength: Signal strength (-1.0 to 1.0)
            confidence: Confidence level (0.0 to 1.0)
            model_id: ID of the alpha model that generated the signal
            timestamp: Signal generation timestamp (seconds since epoch)
            signal_id: Unique signal identifier
            metadata: Additional signal metadata
            expiration: Timestamp when signal expires (seconds since epoch)
        """
        self.instrument = instrument
        self.direction = direction
        self.strength = strength
        self.confidence = confidence
        self.model_id = model_id
        self.timestamp = timestamp or time.time()
        self.signal_id = signal_id or f"signal-{uuid.uuid4().hex[:8]}"
        self.metadata = metadata or {}
        self.expiration = expiration or (self.timestamp + 86400)  # Default to 24h expiration

        # Validate direction
        if direction not in ['long', 'short', 'neutral']:
            raise ValueError("Direction must be 'long', 'short', or 'neutral'")

        # Validate strength
        if not -1.0 <= strength <= 1.0:
            raise ValueError("Strength must be between -1.0 and 1.0")

        # Validate confidence
        if not 0.0 <= confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")

    def is_expired(self) -> bool:
        """
        Check if the signal has expired.

        Returns:
            bool: True if signal has expired, False otherwise
        """
        return time.time() > self.expiration

    def adjusted_strength(self) -> float:
        """
        Get strength adjusted by confidence.

        Returns:
            float: Strength adjusted by confidence level
        """
        return self.strength * self.confidence

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert signal to dictionary for serialization.

        Returns:
            Dict representation of the signal
        """
        return {
            'instrument': self.instrument,
            'direction': self.direction,
            'strength': self.strength,
            'confidence': self.confidence,
            'model_id': self.model_id,
            'timestamp': self.timestamp,
            'signal_id': self.signal_id,
            'metadata': self.metadata,
            'expiration': self.expiration
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AlphaSignal':
        """
        Create signal from dictionary.

        Args:
            data: Dict representation of a signal

        Returns:
            AlphaSignal instance
        """
        return cls(
            instrument=data['instrument'],
            direction=data['direction'],
            strength=data['strength'],
            confidence=data['confidence'],
            model_id=data['model_id'],
            timestamp=data.get('timestamp', time.time()),
            signal_id=data.get('signal_id'),
            metadata=data.get('metadata', {}),
            expiration=data.get('expiration')
        )

    def __repr__(self) -> str:
        """String representation of the signal."""
        return (f"AlphaSignal(instrument={self.instrument}, direction={self.direction}, "
                f"strength={self.strength:.2f}, confidence={self.confidence:.2f})")


class AlphaModel(ABC):
    """
    Abstract base class for alpha models.

    Alpha models are responsible for generating trading signals (alpha values)
    across different instruments based on various data inputs.
    """

    def __init__(self, model_id: str = None, parameters: Dict[str, Any] = None):
        """
        Initialize a new alpha model.

        Args:
            model_id: Unique identifier for the model
            parameters: Model parameters
        """
        self.model_id = model_id or f"alpha-{uuid.uuid4().hex[:8]}"
        self.parameters = parameters or {}
        self.last_update_time = 0
        self.signals: Dict[str, AlphaSignal] = {}  # Current active signals

        logger.info(f"Initialized alpha model '{self.model_id}'")

    @abstractmethod
    def generate_signals(self, data: Dict[str, pd.DataFrame]) -> List[AlphaSignal]:
        """
        Generate alpha signals for the given data.

        Args:
            data: Dict mapping instrument IDs to their data frames

        Returns:
            List of alpha signals
        """
        pass

    def update(self, data: Dict[str, pd.DataFrame]) -> List[AlphaSignal]:
        """
        Update the model with new data and generate signals.

        Args:
            data: Dict mapping instrument IDs to their data frames

        Returns:
            List of new signals
        """
        # Record update time
        self.last_update_time = time.time()

        # Generate new signals
        new_signals = self.generate_signals(data)

        # Update signals dictionary
        for signal in new_signals:
            self.signals[signal.signal_id] = signal

            # Emit signal event
            EventBus.emit("alpha.signal", {
                'model_id': self.model_id,
                'signal': signal.to_dict(),
                'timestamp': time.time()
            })

        # Remove expired signals
        self._clean_expired_signals()

        return new_signals

    def get_active_signals(self) -> List[AlphaSignal]:
        """
        Get all active (non-expired) signals.

        Returns:
            List of active signals
        """
        self._clean_expired_signals()
        return list(self.signals.values())

    def get_signal(self, signal_id: str) -> Optional[AlphaSignal]:
        """
        Get a specific signal by ID.

        Args:
            signal_id: ID of the signal to retrieve

        Returns:
            AlphaSignal or None if not found
        """
        return self.signals.get(signal_id)

    def get_instrument_signals(self, instrument: str) -> List[AlphaSignal]:
        """
        Get all active signals for a specific instrument.

        Args:
            instrument: Instrument ID

        Returns:
            List of active signals for the instrument
        """
        self._clean_expired_signals()
        return [s for s in self.signals.values() if s.instrument == instrument]

    def clear_signals(self) -> int:
        """
        Clear all signals.

        Returns:
            Number of signals cleared
        """
        count = len(self.signals)
        self.signals.clear()
        return count

    def _clean_expired_signals(self) -> None:
        """Remove expired signals from the signals dictionary."""
        expired_ids = [sid for sid, signal in self.signals.items() if signal.is_expired()]
        for sid in expired_ids:
            del self.signals[sid]

    @abstractmethod
    def get_required_features(self) -> Dict[str, Set[str]]:
        """
        Get the features required by this model for each instrument.

        Returns:
            Dict mapping instrument types to sets of required features
        """
        pass

    def get_parameters(self) -> Dict[str, Any]:
        """
        Get the model parameters.

        Returns:
            Dict of model parameters
        """
        return self.parameters.copy()

    def set_parameters(self, parameters: Dict[str, Any]) -> None:
        """
        Set model parameters.

        Args:
            parameters: New parameters to set
        """
        self.parameters.update(parameters)

        # Emit parameter update event
        EventBus.emit("alpha.parameter_update", {
            'model_id': self.model_id,
            'parameters': self.parameters.copy(),
            'timestamp': time.time()
        })

    def get_model_info(self) -> Dict[str, Any]:
        """
        Get information about the model.

        Returns:
            Dict with model information
        """
        return {
            'model_id': self.model_id,
            'model_type': self.__class__.__name__,
            'parameters': self.parameters.copy(),
            'last_update_time': self.last_update_time,
            'active_signals_count': len(self.signals)
        }