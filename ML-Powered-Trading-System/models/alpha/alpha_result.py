"""
Alpha Result Module

This module defines the AlphaResult class, which standardizes how signals
are passed from alpha models to portfolio construction components.

AlphaResult serves as the contract between signal generation (from strategies
and models) and portfolio construction (optimization and trade generation).
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Any, Set
from enum import Enum
from datetime import datetime
import uuid
import logging
from dataclasses import dataclass, field

# Import system components
from execution.order.order import OrderSide

# Configure logger
logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of signals that can be generated by alpha models"""
    DIRECTIONAL = "directional"  # Long/short directional signal
    RELATIVE_VALUE = "relative_value"  # Pair/basket relative value signal
    VOLATILITY = "volatility"  # Volatility-based signal
    REVERSAL = "reversal"  # Mean reversion/reversal signal
    MOMENTUM = "momentum"  # Trend/momentum signal
    PATTERN = "pattern"  # Chart pattern signal
    REGIME_CHANGE = "regime_change"  # Market regime change signal
    CUSTOM = "custom"  # Custom signal type


class SignalDirection(Enum):
    """Direction of a trading signal"""
    LONG = "long"  # Positive expectation / buy signal
    SHORT = "short"  # Negative expectation / sell signal
    NEUTRAL = "neutral"  # No clear directional bias

    @property
    def to_order_side(self) -> OrderSide:
        """Convert signal direction to order side"""
        if self == SignalDirection.LONG:
            return OrderSide.BUY
        elif self == SignalDirection.SHORT:
            return OrderSide.SELL
        else:
            raise ValueError(f"Cannot convert {self.value} to OrderSide")


class SignalStrength(Enum):
    """Categorical strength of a signal"""
    VERY_WEAK = 1
    WEAK = 2
    MODERATE = 3
    STRONG = 4
    VERY_STRONG = 5


class SignalTimeframe(Enum):
    """Timeframe for which the signal is valid"""
    INTRADAY = "intraday"  # Signal valid for intraday trading (minutes to hours)
    DAILY = "daily"  # Signal valid for 1-3 days
    SWING = "swing"  # Signal valid for days to weeks
    POSITION = "position"  # Signal valid for weeks to months
    CUSTOM = "custom"  # Custom timeframe with explicit duration


class AlphaSource(Enum):
    """Source of the alpha signal"""
    TECHNICAL = "technical"  # Technical analysis
    FUNDAMENTAL = "fundamental"  # Fundamental analysis
    STATISTICAL = "statistical"  # Statistical analysis
    MACHINE_LEARNING = "ml"  # Machine learning model
    SENTIMENT = "sentiment"  # Sentiment or news-based
    ENSEMBLE = "ensemble"  # Ensemble of multiple sources
    CUSTOM = "custom"  # Custom source


@dataclass
class AlphaResult:
    """
    Standardized container for alpha model signals to be passed to
    portfolio construction.

    This class represents the output of an alpha model or trading strategy
    containing all necessary information for the portfolio construction
    process to make appropriate sizing and execution decisions.
    """
    # Core signal attributes
    symbol: str  # Trading instrument symbol
    direction: SignalDirection  # Long or short bias
    conviction: float  # Numeric signal strength/conviction score (0.0 to 1.0)
    timestamp: datetime = field(default_factory=datetime.utcnow)  # When the signal was generated

    # Signal metadata
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))  # Unique identifier
    model_id: Optional[str] = None  # ID of the model that generated this signal
    strategy_id: Optional[str] = None  # ID of the strategy that generated this signal

    # Signal context
    signal_type: SignalType = SignalType.DIRECTIONAL  # Type of signal
    timeframe: SignalTimeframe = SignalTimeframe.DAILY  # Intended timeframe
    source: AlphaSource = AlphaSource.TECHNICAL  # Source of the signal

    # Prediction details
    target_price: Optional[float] = None  # Target price (if applicable)
    stop_price: Optional[float] = None  # Stop loss price (if applicable)
    expected_return: Optional[float] = None  # Expected return (forecast)
    expected_volatility: Optional[float] = None  # Expected volatility
    probability: Optional[float] = None  # Probability of success/confidence

    # Time validity
    expiration: Optional[datetime] = None  # When the signal expires
    time_to_expiration: Optional[float] = None  # Hours until expiration

    # Trade execution parameters
    execution_window: Optional[float] = None  # Window for execution in hours
    urgency: float = 0.5  # Urgency score (0.0 to 1.0)
    max_impact: Optional[float] = None  # Maximum allowed market impact

    # Risk parameters
    max_position_size: Optional[float] = None  # Maximum position size
    risk_contribution: Optional[float] = None  # Target risk contribution
    correlation_factor: Optional[float] = None  # Correlation to portfolio

    # Additional information
    features: Dict[str, float] = field(default_factory=dict)  # Key features that led to signal
    tags: List[str] = field(default_factory=list)  # Tags for categorization
    metadata: Dict[str, Any] = field(default_factory=dict)  # Additional metadata
    notes: Optional[str] = None  # Additional notes

    def __post_init__(self):
        """Validate and initialize the alpha result after creation."""
        # Validate conviction range
        if not 0.0 <= self.conviction <= 1.0:
            raise ValueError(f"Conviction score must be between 0.0 and 1.0, got {self.conviction}")

        # Ensure urgency is in valid range
        if not 0.0 <= self.urgency <= 1.0:
            raise ValueError(f"Urgency score must be between 0.0 and 1.0, got {self.urgency}")

        # Log creation
        logger.info(f"Created {self.signal_type.value} signal for {self.symbol}: "
                    f"{self.direction.value} with {self.conviction:.2f} conviction")

    @property
    def strength_category(self) -> SignalStrength:
        """Get the categorical strength based on conviction score"""
        if self.conviction < 0.2:
            return SignalStrength.VERY_WEAK
        elif self.conviction < 0.4:
            return SignalStrength.WEAK
        elif self.conviction < 0.6:
            return SignalStrength.MODERATE
        elif self.conviction < 0.8:
            return SignalStrength.STRONG
        else:
            return SignalStrength.VERY_STRONG

    @property
    def is_valid(self) -> bool:
        """Check if the signal is still valid (not expired)"""
        if self.expiration is None:
            return True
        return datetime.utcnow() < self.expiration

    @property
    def time_since_generation(self) -> float:
        """Get the time since signal generation in hours"""
        delta = datetime.utcnow() - self.timestamp
        return delta.total_seconds() / 3600

    @property
    def primary_feature(self) -> Optional[tuple]:
        """Get the most important feature and its value"""
        if not self.features:
            return None
        return max(self.features.items(), key=lambda x: abs(x[1]))

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to dictionary for serialization.

        Returns:
            Dict containing all alpha result data
        """
        result = {
            # Core signal attributes
            "symbol": self.symbol,
            "direction": self.direction.value,
            "conviction": self.conviction,
            "timestamp": self.timestamp.isoformat(),

            # Signal metadata
            "signal_id": self.signal_id,
            "model_id": self.model_id,
            "strategy_id": self.strategy_id,

            # Signal context
            "signal_type": self.signal_type.value,
            "timeframe": self.timeframe.value,
            "source": self.source.value,

            # Prediction details
            "target_price": self.target_price,
            "stop_price": self.stop_price,
            "expected_return": self.expected_return,
            "expected_volatility": self.expected_volatility,
            "probability": self.probability,

            # Time validity
            "expiration": self.expiration.isoformat() if self.expiration else None,
            "time_to_expiration": self.time_to_expiration,

            # Trade execution parameters
            "execution_window": self.execution_window,
            "urgency": self.urgency,
            "max_impact": self.max_impact,

            # Risk parameters
            "max_position_size": self.max_position_size,
            "risk_contribution": self.risk_contribution,
            "correlation_factor": self.correlation_factor,

            # Additional information
            "features": self.features,
            "tags": self.tags,
            "metadata": self.metadata,
            "notes": self.notes,

            # Computed properties
            "strength_category": self.strength_category.name,
            "is_valid": self.is_valid,
        }

        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AlphaResult':
        """
        Create an AlphaResult instance from a dictionary.

        Args:
            data: Dictionary containing alpha result data

        Returns:
            AlphaResult instance
        """
        # Make a copy to avoid modifying the original
        result_data = data.copy()

        # Convert string enums back to enum types
        if "direction" in result_data and isinstance(result_data["direction"], str):
            result_data["direction"] = SignalDirection(result_data["direction"])

        if "signal_type" in result_data and isinstance(result_data["signal_type"], str):
            result_data["signal_type"] = SignalType(result_data["signal_type"])

        if "timeframe" in result_data and isinstance(result_data["timeframe"], str):
            result_data["timeframe"] = SignalTimeframe(result_data["timeframe"])

        if "source" in result_data and isinstance(result_data["source"], str):
            result_data["source"] = AlphaSource(result_data["source"])

        # Convert ISO timestamps back to datetime
        if "timestamp" in result_data and isinstance(result_data["timestamp"], str):
            result_data["timestamp"] = datetime.fromisoformat(result_data["timestamp"])

        if "expiration" in result_data and result_data["expiration"] and isinstance(result_data["expiration"], str):
            result_data["expiration"] = datetime.fromisoformat(result_data["expiration"])

        # Remove computed properties
        result_data.pop("strength_category", None)
        result_data.pop("is_valid", None)

        return cls(**result_data)

    def __str__(self) -> str:
        """String representation of the alpha result"""
        return (f"{self.signal_type.value.capitalize()} {self.direction.value} signal for {self.symbol}: "
                f"conviction={self.conviction:.2f}, timeframe={self.timeframe.value}")


class AlphaResultCollection:
    """
    Collection of AlphaResult objects for multi-symbol or portfolio-level signals.

    This class is useful for strategies that generate signals for multiple
    instruments simultaneously, or for aggregating signals from multiple
    strategies/models.
    """

    def __init__(self, signals: Optional[List[AlphaResult]] = None):
        """
        Initialize the collection.

        Args:
            signals: Optional list of AlphaResult objects
        """
        self.signals = signals or []
        self.collection_id = str(uuid.uuid4())
        self.timestamp = datetime.utcnow()

    def add_signal(self, signal: AlphaResult) -> None:
        """
        Add a signal to the collection.

        Args:
            signal: AlphaResult object to add
        """
        self.signals.append(signal)

    def remove_signal(self, signal_id: str) -> bool:
        """
        Remove a signal from the collection by ID.

        Args:
            signal_id: ID of the signal to remove

        Returns:
            True if signal was removed, False if not found
        """
        initial_count = len(self.signals)
        self.signals = [s for s in self.signals if s.signal_id != signal_id]
        return len(self.signals) < initial_count

    def get_signal(self, signal_id: str) -> Optional[AlphaResult]:
        """
        Get a signal by ID.

        Args:
            signal_id: ID of the signal to retrieve

        Returns:
            AlphaResult object or None if not found
        """
        for signal in self.signals:
            if signal.signal_id == signal_id:
                return signal
        return None

    def get_signals_by_symbol(self, symbol: str) -> List[AlphaResult]:
        """
        Get all signals for a specific symbol.

        Args:
            symbol: Symbol to filter by

        Returns:
            List of AlphaResult objects for the symbol
        """
        return [s for s in self.signals if s.symbol == symbol]

    def get_signals_by_direction(self, direction: SignalDirection) -> List[AlphaResult]:
        """
        Get all signals with a specific direction.

        Args:
            direction: Direction to filter by

        Returns:
            List of AlphaResult objects with the specified direction
        """
        return [s for s in self.signals if s.direction == direction]

    @property
    def symbols(self) -> List[str]:
        """Get the list of unique symbols in the collection"""
        return sorted(list(set(s.symbol for s in self.signals)))

    @property
    def count(self) -> int:
        """Get the number of signals in the collection"""
        return len(self.signals)

    @property
    def valid_signals(self) -> List[AlphaResult]:
        """Get only the valid (non-expired) signals"""
        return [s for s in self.signals if s.is_valid]

    def to_dataframe(self) -> pd.DataFrame:
        """
        Convert the collection to a pandas DataFrame.

        Returns:
            DataFrame with all signals and their attributes
        """
        if not self.signals:
            return pd.DataFrame()

        # Convert all signals to dicts
        signal_dicts = [s.to_dict() for s in self.signals]

        # Create DataFrame
        return pd.DataFrame(signal_dicts)

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the collection to a dictionary for serialization.

        Returns:
            Dict containing collection data
        """
        return {
            "collection_id": self.collection_id,
            "timestamp": self.timestamp.isoformat(),
            "count": self.count,
            "symbols": self.symbols,
            "signals": [s.to_dict() for s in self.signals]
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AlphaResultCollection':
        """
        Create an AlphaResultCollection from a dictionary.

        Args:
            data: Dictionary containing collection data

        Returns:
            AlphaResultCollection instance
        """
        collection = cls()

        if "collection_id" in data:
            collection.collection_id = data["collection_id"]

        if "timestamp" in data and isinstance(data["timestamp"], str):
            collection.timestamp = datetime.fromisoformat(data["timestamp"])

        if "signals" in data and isinstance(data["signals"], list):
            for signal_data in data["signals"]:
                signal = AlphaResult.from_dict(signal_data)
                collection.add_signal(signal)

        return collection

    def __str__(self) -> str:
        """String representation of the collection"""
        return f"AlphaResultCollection with {self.count} signals for {len(self.symbols)} symbols"


def create_alpha_result_from_strategy(
    strategy_result: Dict[str, Any],
    strategy_id: str,
    symbol: str,
    **kwargs
) -> AlphaResult:
    """
    Create an AlphaResult from a strategy's output.

    This factory function helps standardize the conversion from
    various strategy outputs to the AlphaResult format.

    Args:
        strategy_result: Strategy output dictionary
        strategy_id: ID of the strategy
        symbol: Trading symbol
        **kwargs: Additional parameters to pass to AlphaResult

    Returns:
        AlphaResult instance
    """
    # Extract signal direction
    if "signal" in strategy_result:
        signal = strategy_result["signal"]
        if signal == "long":
            direction = SignalDirection.LONG
        elif signal == "short":
            direction = SignalDirection.SHORT
        else:
            direction = SignalDirection.NEUTRAL
    else:
        # Default to neutral if no signal
        direction = SignalDirection.NEUTRAL

    # Extract conviction
    conviction = strategy_result.get("conviction", 0.5)

    # Create basic AlphaResult
    result = AlphaResult(
        symbol=symbol,
        direction=direction,
        conviction=conviction,
        strategy_id=strategy_id,
        **kwargs
    )

    # Add additional information if available
    if "target_price" in strategy_result:
        result.target_price = strategy_result["target_price"]

    if "stop_loss" in strategy_result:
        result.stop_price = strategy_result["stop_loss"]

    if "expected_return" in strategy_result:
        result.expected_return = strategy_result["expected_return"]

    if "probability" in strategy_result:
        result.probability = strategy_result["probability"]

    if "features" in strategy_result and isinstance(strategy_result["features"], dict):
        result.features = strategy_result["features"]

    if "notes" in strategy_result:
        result.notes = strategy_result["notes"]

    return result


def merge_alpha_results(
    results: List[AlphaResult],
    symbol: str,
    merge_method: str = "conviction_weighted"
) -> AlphaResult:
    """
    Merge multiple AlphaResults for the same symbol.

    This function is useful for ensemble models or when combining
    signals from multiple strategies for the same instrument.

    Args:
        results: List of AlphaResult objects to merge
        symbol: Symbol these results are for
        merge_method: Method to use for merging ("conviction_weighted",
                      "majority_vote", "highest_conviction")

    Returns:
        Merged AlphaResult instance
    """
    if not results:
        raise ValueError("Cannot merge empty list of results")

    # Filter for matching symbol
    symbol_results = [r for r in results if r.symbol == symbol]

    if not symbol_results:
        raise ValueError(f"No results found for symbol {symbol}")

    # Handle single result case
    if len(symbol_results) == 1:
        return symbol_results[0]

    # Merge based on selected method
    if merge_method == "conviction_weighted":
        # Calculate the weighted average of directions and convictions
        total_weight = sum(r.conviction for r in symbol_results)

        # Count weighted votes for each direction
        direction_votes = {
            SignalDirection.LONG: sum(r.conviction for r in symbol_results if r.direction == SignalDirection.LONG),
            SignalDirection.SHORT: sum(r.conviction for r in symbol_results if r.direction == SignalDirection.SHORT),
            SignalDirection.NEUTRAL: sum(r.conviction for r in symbol_results if r.direction == SignalDirection.NEUTRAL)
        }

        # Determine majority direction
        if total_weight > 0:
            majority_direction = max(direction_votes.items(), key=lambda x: x[1])[0]
            # Calculate net conviction as difference between long and short
            net_conviction = abs(direction_votes[SignalDirection.LONG] - direction_votes[SignalDirection.SHORT]) / total_weight
        else:
            majority_direction = SignalDirection.NEUTRAL
            net_conviction = 0.0

    elif merge_method == "majority_vote":
        # Count votes for each direction
        direction_counts = {
            SignalDirection.LONG: sum(1 for r in symbol_results if r.direction == SignalDirection.LONG),
            SignalDirection.SHORT: sum(1 for r in symbol_results if r.direction == SignalDirection.SHORT),
            SignalDirection.NEUTRAL: sum(1 for r in symbol_results if r.direction == SignalDirection.NEUTRAL)
        }

        # Determine majority direction
        majority_direction = max(direction_counts.items(), key=lambda x: x[1])[0]

        # Calculate conviction as fraction of votes for majority
        max_votes = direction_counts[majority_direction]
        net_conviction = max_votes / len(symbol_results)

    elif merge_method == "highest_conviction":
        # Take the result with the highest conviction
        highest_result = max(symbol_results, key=lambda r: r.conviction)
        return highest_result

    else:
        raise ValueError(f"Unknown merge method: {merge_method}")

    # Create merged result
    merged_result = AlphaResult(
        symbol=symbol,
        direction=majority_direction,
        conviction=min(net_conviction, 1.0),  # Cap at 1.0
        timestamp=datetime.utcnow()
    )

    # Average numeric properties
    numeric_props = [
        "target_price", "stop_price", "expected_return",
        "expected_volatility", "probability", "risk_contribution"
    ]

    for prop in numeric_props:
        values = [getattr(r, prop) for r in symbol_results if getattr(r, prop) is not None]
        if values:
            setattr(merged_result, prop, sum(values) / len(values))

    # Set the shortest expiration
    expirations = [r.expiration for r in symbol_results if r.expiration is not None]
    if expirations:
        merged_result.expiration = min(expirations)

    # Combine tags
    all_tags = set()
    for r in symbol_results:
        all_tags.update(r.tags)
    merged_result.tags = list(all_tags)

    # Combine features (average values)
    feature_values = {}
    for r in symbol_results:
        for feature, value in r.features.items():
            if feature not in feature_values:
                feature_values[feature] = []
            feature_values[feature].append(value)

    merged_result.features = {
        feature: sum(values) / len(values)
        for feature, values in feature_values.items()
    }

    # Track source results
    merged_result.metadata["source_signals"] = [r.signal_id for r in symbol_results]
    merged_result.metadata["merge_method"] = merge_method

    return merged_result